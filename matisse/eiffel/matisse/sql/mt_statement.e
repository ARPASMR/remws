note
	description: "MATISSE-Eiffel Binding: define the SQL statement class"
	license: "[
	The contents of this file are subject to the Matisse Interfaces 
	Public License Version 1.0 (the 'License'); you may not use this 
	file except in compliance with the License. You may obtain a copy of
	the License at http://www.matisse.com/pdf/developers/MIPL.html

	Software distributed under the License is distributed on an 'AS IS'
	basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See 
	the License for the specific language governing rights and
	limitations under the License.

	The Original Code was created by Matisse Software Inc. 
	and its successors.

	The Initial Developer of the Original Code is Matisse Software Inc. 
	Portions created by Matisse Software are Copyright (C) 
	Matisse Software Inc. All Rights Reserved.

	Contributor(s): Kazuhiro Nakao
                   Didier Cabannes
                   Neal Lester
                   Luca Paganotti
	]"

class
	MT_STATEMENT

create
	make

feature -- SQL Stmt Type

	MtSql_Allocated: INTEGER_32 = 1
	MtSql_Select: INTEGER_32 = 2
	MtSql_Set_Transaction: INTEGER_32 = 3
	MtSql_Set_Option: INTEGER_32 = 4
	MtSql_Drop_Selection: INTEGER_32 = 5
	MtSql_Commit: INTEGER_32 = 6
	MtSql_Rollback: INTEGER_32 = 7
	MtSql_Update: INTEGER_32 = 8
	MtSql_Delete: INTEGER_32 = 9
	MtSql_Insert: INTEGER_32 = 10
	MtSql_Alter_Add: INTEGER_32 = 11
	MtSql_Alter_Drop: INTEGER_32 = 12
	MtSql_Alter_Alter: INTEGER_32 = 13
	MtSql_Alter_Rename: INTEGER_32 = 14
	MtSql_Drop: INTEGER_32 = 15
	MtSql_Create: INTEGER_32 = 16
	MtSql_Event: INTEGER_32 = 17
	MtSql_Method: INTEGER_32 = 18
	MtSql_Procedure: INTEGER_32 = 19
	MtSql_Compile: INTEGER_32 = 20
	MtSql_Parse: INTEGER_32 = 21
	MtSql_Error: INTEGER_32 = 22

feature -- SQL Stmt Attr

	MtSql_Stmt_Selection: INTEGER_32 = 1
	MtSql_Stmt_Selclass: INTEGER_32 = 2
	MtSql_Stmt_Option: INTEGER_32 = 3
	MtSql_Stmt_Value: INTEGER_32 = 4
	MtSql_Stmt_Numobjects: INTEGER_32 = 5
	MtSql_Stmt_Numqualified: INTEGER_32 = 6
	MtSql_Stmt_Errposition: INTEGER_32 = 7
	MtSql_Stmt_Errline: INTEGER_32 = 8
	MtSql_Stmt_Errstack: INTEGER_32 = 9
	MtSql_Stmt_Type: INTEGER_32 = 10
	MtSql_Stmt_Server: INTEGER_32 = 11
	MtSql_Stmt_Database: INTEGER_32 = 12
	MtSql_Stmt_Uid: INTEGER_32 = 13
	MtSql_Stmt_Readonly: INTEGER_32 = 14
	MtSql_Stmt_Version: INTEGER_32 = 15
	MtSql_Stmt_Priority: INTEGER_32 = 16
	MtSql_Stmt_Class: INTEGER_32 = 17
	MtSql_Stmt_Superclass: INTEGER_32 = 18
	MtSql_Stmt_Attribute: INTEGER_32 = 19
	MtSql_Stmt_Relationship: INTEGER_32 = 20
	MtSql_Stmt_Method: INTEGER_32 = 21
	MtSql_Stmt_Index: INTEGER_32 = 22
	MtSql_Stmt_Entrypoint: INTEGER_32 = 23


feature {MT_DATABASE} -- Initialization

	make (a_db: MT_DATABASE)
		require
			valid_a_db: a_db /= Void
		do
			mtdb := a_db
			stmt_offset := mtdb.context.sql_alloc_stmt ()
		ensure
			stmt_allocated: stmt_offset > 0
		end

feature -- Query

	execute_query (query_stmt: STRING): MT_RESULT_SET
			-- Execute a SQL SELECT statement, then return a result set.
			-- If there is already an open result set generated by the previous
			-- SQL execution, it'll be closed implicitly before this execution.
		require
			stmt_not_void: query_stmt /= Void
			is_open: is_open
			--tran_or_version: mtdb.is_access_open
		local
			to_c: ANY
		do
			clean_up_before_execution
			to_c := query_stmt.to_c
			mtdb.context.sql_exec_query ( stmt_offset, $to_c)
			create Result.make (Current)
			result_set_impl := Result
		ensure
			result_not_void: Result /= Void
		end

	execute_update (sql_stmt: STRING): INTEGER_32
			-- Executes an SQL INSERT, UPDATE or DELETE statement.
			-- Returns the number of objects affected by the statement.
			-- SQL DDL statements can be executed, too.
		require
			stmt_not_void: sql_stmt /= Void
			is_open: is_open
			--tran_or_version: mtdb.is_access_open
		local
			to_c: ANY
		do
			clean_up_before_execution
			to_c := sql_stmt.to_c
			Result := mtdb.context.sql_exec_update ( stmt_offset, $to_c)
		end

	execute (sql_stmt: STRING): BOOLEAN
			-- Can execute any kind of SQL statement.
			-- Returns true if the executed statement was SELECT statement,
			-- otherwise returns false.
			-- Use {MT_STATEMENT}.result_set to get the result set for
			-- previously executed SELECT statement.
		require
			stmt_not_void: sql_stmt /= Void
			is_open: is_open
			--tran_or_version: mtdb.is_access_open
		local
			to_c: ANY
		do
			clean_up_before_execution
			to_c := sql_stmt.to_c
			Result := mtdb.context.sql_exec ( stmt_offset, $to_c)
		end

feature -- Get result

	get_result_set, result_set: MT_RESULT_SET
			-- Retruns a result set object of the previously executed
			-- SELECT statement using the execute() routine.
			--  Void will be returned if
			-- (1) the executed statement was not SELECT, or
			-- (2) no statement is not executed yet, or
			-- (3) a result set is already open
		require
			is_open: is_open
		do
			if get_statement_type = MtSql_Select then
					if result_set_impl = Void then
						create Result.make (Current)
						result_set_impl := Result
					elseif not result_set_impl.is_open then
						Result := result_set_impl
					end
			else
				Result := Void
			end
		end

	get_update_count, update_count: INTEGER_32
			-- Returns an update count of the previously executed statement.
			-- If the executed statement was not either UPDATE, DELETE, nor
			-- INSERT, -1 will be returned.
		require
			is_open: is_open
		do
			Result := mtdb.context.sql_get_update_count ( stmt_offset)
		end

	get_statement_type, statement_type: INTEGER_32
			-- Return the type of a SQL statement that was executed.
			-- Those type constants are defined in MT_CONSTANTS.
		require
			is_open: is_open
		do
			Result := mtdb.context.sql_get_stmt_type ( stmt_offset)
		ensure
			MtSql_Allocated <= Result and Result < MtSql_Error
		end

	get_statement_info, statement_info (stmt_attribute: INTEGER_32): STRING
			-- Return information of the statement regarding the stmt_attribute
		require
			is_open: is_open
			valid_stmt_attribute: MtSql_Stmt_Selection <= stmt_attribute and
														stmt_attribute <= MtSql_Stmt_Entrypoint
		do
			Result := mtdb.context.sql_get_stmt_info ( stmt_offset, stmt_attribute)
		end


	stmt_type_to_string (stmt_type: INTEGER_32): STRING
		require stmt_type >= MtSql_Allocated and stmt_type <= MtSql_Error
			valid_stmt_type:
		local
			st_name: STRING
		do
			inspect stmt_type
			when MtSql_Allocated then st_name := "Allocated"
			when MtSql_Select then st_name := "Select"
			when MtSql_Set_Transaction then st_name := "Set_Transaction"
			when MtSql_Set_Option then st_name := "Set_Option"
			when MtSql_Drop_Selection then st_name := "Drop_Selection"
			when MtSql_Commit then st_name := "Commit"
			when MtSql_Rollback then st_name := "Rollback"
			when MtSql_Update then st_name := "Update"
			when MtSql_Delete then st_name := "Delete"
			when MtSql_Insert then st_name := "Insert"
			when MtSql_Alter_Add then st_name := "Alter_Add"
			when MtSql_Alter_Drop then st_name := "Alter_Drop"
			when MtSql_Alter_Alter then st_name := "Alter_Alter"
			when MtSql_Alter_Rename then st_name := "Alter_Rename"
			when MtSql_Drop then st_name := "Drop"
			when MtSql_Create then st_name := "Create"
			when MtSql_Event then st_name := "Event"
			when MtSql_Method then st_name := "Method"
			when MtSql_Procedure then st_name := "Procedure"
			when MtSql_Compile then st_name := "Compile"
			when MtSql_Parse then st_name := "Parse"
			when MtSql_Error then st_name := "Error"
			else st_name := "Unknown(" + stmt_type.out + ")"
			end
			Result := st_name.twin
		end
feature -- Status report

	is_open: BOOLEAN
			-- Is this object ready for use, e.g., executing SQL statements?
		do
			Result := stmt_offset > 0
		end

feature -- Status setting

	close
			-- Free the MATISSE statement object allocated in the C-library.
			-- If the related MT_RESULT_SET object is still open, close it.
		require
			stmt_allocated: is_open
		do
			if result_set_impl /= Void then
				if result_set_impl.is_open then
					result_set_impl.close
				end
			end
			mtdb.context.sql_free_stmt ( stmt_offset)
			stmt_offset := invalid_stmt_offset
		ensure
			result_set_closed: result_set_impl /= Void implies not result_set_impl.is_open
			closed: not is_open
		end

feature -- Attribute

	mtdb: MT_DATABASE

	get_database: MT_DATABASE
		do
			Result := mtdb
		end

feature {NONE} -- Implementation

	result_set_impl: MT_RESULT_SET
	invalid_stmt_offset: INTEGER_32 = -1

	clean_up_before_execution
		do
			if result_set_impl /= Void then
				-- implicitly close the result set previously opened
				-- by the current object
				if result_set_impl.is_open then
					result_set_impl.close
				end
			end
		end

feature {MT_RESULT_SET} -- Implementation

	stmt_offset: INTEGER_32 -- MtSQLStmt

end -- class MT_STATEMENT
