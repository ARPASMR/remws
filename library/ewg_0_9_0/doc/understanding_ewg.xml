<?xml version="1.0"?>

<!--
description:

"Understanding Ewg"

copyright: "Copyright (c) 2004-2005, Andreas Leitner and others"
license: "Eiffel Forum License v2 (see forum.txt)"
date: "$Date$"
revision: "$Revision$"

-->

<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="ewg/understanding_ewg">
  <chapterinfo>
    <copyright>
      <year>2004-2005</year>
      <holder>Andreas Leitner</holder>
    </copyright>
    <author>
      <firstname>Andreas</firstname><surname>Leitner</surname>
    </author>
    <email>aleitner@raboof.at</email>
    <date>8 March 2005</date>
  </chapterinfo>

  <title>Understanding Ewg</title>

  <title>Understanding EWG</title>
  
  <para>
    This chapter describes what code EWG generates and how to integrate that
    code into a automated build system.
  </para>

  <section id="command_line_options">
    <title>Command Line Options</title>
    <para>
      The ewg tool is a command line application and takes the following command line parameters:
    </para>
    
    <programlisting><![CDATA[
      ewg   [--version] [--verbose]
	 [--enable-msc-extensions | --disable-msc-extension] [--output-dir=<...>]
	 --cpp-full-header=<...> [--include-header=<...>] [--config=<...>]
      ]]>
      </programlisting>
    
    <itemizedlist>
      <listitem>
	 <para>options:</para>
	 <itemizedlist>
	   <listitem><para>--version ... Output EWG version number</para></listitem>
	   <listitem><para>--verbose ... Output progress information on STDOUT</para></listitem>
	   <listitem><para>--enable-msc-extensions ... Enable Visual C++ extensions (default on Windows)</para></listitem>
	   <listitem><para>--disable-msc-extensions ... Disable Visual C++ extensions (default everywhere else :)</para></listitem>
	 </itemizedlist>
      </listitem>
      <listitem>
	 <para>arguments:</para>
	 <itemizedlist>
	   <listitem><para>--output-dir ... Directory where generated files will be placed</para></listitem>
	   <listitem><para>--cpp-full-header ... File name (including path name) to the already c preprocessed C header</para></listitem>
	   <listitem><para>--include-header ... Name of header file, that should be used in eiffel external clauses</para></listitem>
	   <listitem><para>--config ... Name of config file to use. A config file allows to customize the wrapping process</para></listitem>
	 </itemizedlist>
      </listitem>
    </itemizedlist>
    <para>
      You can use ewg directly to see what it produces on a header of your own without setting up a complete project,
      or use your own build process. Most of the time you will not use the ewg tool directly, but use it indirectly
      through <emphasis>geant</emphasis>.
    </para>

  </section>


  <section id="the_generated_code">
    <title>The Generated Code</title>

    <para>
      As shown in the next figure, EWG takes an already preprocessed C header file and generates Eiffel classes
      and a C glue code library. The generation of the C glue code library might seem a little counter productive
      at first, since we really want to use Eiffel not C. But first of all this generated C code makes accessing the
      C library from Eiffel possible (at least for some constructs) and second of all this generated C code is
      wrapped by the generated Eiffel classes as well, eliminating the need to deal with it directly.
    </para>

    <para>
      <mediaobjectco>
	 <imageobjectco>
	   <imageobject>
	     <imagedata align="center" fileref="image/ewg_flow.png"></imagedata>
	   </imageobject>
	 </imageobjectco>
      </mediaobjectco>
    </para>

    <note>
      <para>
	 The above figure omits one detail, EWG doesn't generate the C glue code library, but rather the C source
	 code files that will have to be compiled and linked (via geant for example) into a library.
      </para>
    </note>

    <para>
      An application that uses the EWG wrapper uses the generated Eiffel Classes and links against the generated
      glue code library as well as to the C library.
    </para>
    
    <para>
      <mediaobjectco>
	 <imageobjectco>
	   <imageobject>
	     <imagedata align="center" fileref="image/application_components.png"></imagedata>
	   </imageobject>
	 </imageobjectco>
      </mediaobjectco>
    </para>

    <para>
      How exactly the application has to be linked is topic of the next chapter. 
    </para>

    <para>
      EWG creates a whole directory structure containing generated source code.
    </para>

    <note>
      <para>
	 You will see that some of the generated files have the file name extension
	 <literal>ge</literal>. Those classes contain macros and need to be preprocessed
	 by <emphasis>gepp</emphasis>. As you will see later out of one such a <literal>.ge</literal>
	 file 4 Eiffel class files will be created, one for each Eiffel compiler. 
      </para>
    </note>

    <para>
      The following shows the directory structure generated by EWG
    </para>

    <itemizedlist>
      <listitem>
	 <para>c -- C source code for c glue library</para>
	 <itemizedlist>
	   <listitem><para>function -- function glue code</para></listitem>      
	 </itemizedlist>
	 <itemizedlist>
	   <listitem><para>struct -- struct glue code</para></listitem>      
	 </itemizedlist>
	 <itemizedlist>
	   <listitem><para>enum -- enum glue code</para></listitem>      
	 </itemizedlist>
	 <itemizedlist>
	   <listitem><para>ewg_c_library -- basic c library copied from <literal>${EWG}/library/runtime/c</literal></para></listitem>      
	 </itemizedlist>
	 <itemizedlist>
	   <listitem><para>callback -- callback glue code</para></listitem>      
	 </itemizedlist>
      </listitem>      
      <listitem>
	 <para>eiffel -- eiffel classes</para>
	 <itemizedlist>
	   <listitem>
	     <para>external -- low level wrapper classes</para>
	     <itemizedlist>
		<listitem><para>callback -- low level wrapper for callbacks</para></listitem>      
		<listitem><para>enum -- low level wrapper for enums</para></listitem>      
		<listitem><para>struct -- low level wrapper for structs</para></listitem>      
		<listitem><para>union -- low level wrapper for unions</para></listitem>      
		<listitem><para>function -- low level wrapper for functions</para></listitem>      
	     </itemizedlist>
	   </listitem>      
	   <listitem>
	     <para>abstraction -- higher level wrapper classes</para>
	     <itemizedlist>
		<listitem><para>callback -- higher level wrapper for callbacks</para></listitem>      
		<listitem><para>enum -- higher level wrapper for enums</para></listitem>      
		<listitem><para>struct -- higher level wrapper for structs</para></listitem>      
		<listitem><para>union -- higher level wrapper for unions</para></listitem>      
		<listitem><para>function -- higher level wrapper for functions</para></listitem>      
	     </itemizedlist>
	   </listitem>      
	 </itemizedlist>
      </listitem>      
    </itemizedlist>
    
    <para>
      As you can see there are low-level and higher level wrappers.
      For a library to become usable for application developers you have to provide
      a third layer that uses the lower layers, but provides a consistent object oriented
      interface.
    </para>
    
    <section id="functions">
      <title>Functions</title>
      <para>
	 This section describes what code gets generated for a C function declaration and how 
	 to use that code to call the declared function.
      </para>

      <para>
	 Let us look at the following function declaration (taken from the <literal>simple-example</literal>)
      </para>
      <informalexample>
	 <programlisting>
	   <![CDATA[
int func2 (int a, int b);
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 <literal>func2</literal> is a function that takes two parameters of type <literal>int</literal> and
	 returns a value of type <literal>int</literal>. EWG generates an Eiffel wrapper class for it in the cluster
	 <literal>eiffel\external\function</literal>:
      </para>

      <informalexample>
	 <programlisting>
class SIMPLE_HEADER_FUNCTIONS_EXTERNAL

feature

    func2_external (a: INTEGER; b: INTEGER) : INTEGER

    get_func2_pointer_external: POINTER

end
	 </programlisting>
      </informalexample>

      <para>
	 The name of the class is <literal>SIMPLE_HEADER_FUNCTIONS_EXTERNAL</literal>. This is because
	 the function declaration comes from the C header file <literal>simple_header.h</literal>.
	 EWG will put all function declarations from the same header in the same class.
      </para>

      <para>
	 <literal>func2_external</literal> is the routine you will want to call if you want to execute the
	 c function <literal>func2</literal>. <literal>get_func2_pointer_external</literal> gives you the address
	 of the C function. You need the address of an function if you want to pass it as a callback for example.
      </para>

      <para>For functions only low-level wrappers are generated.</para>

    </section>

    <section id="structs">
      <title>Structs</title>
      <para>
	 This section describes what code gets generated for a C struct declaration and how 
	 to use that code to create, free, read from and write to a struct.
      </para>

      <section id="low_level_structs">
	 <title>Low Level Struct Wrappers</title>

	 <para>
	   Let us look at the following struct declaration:
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
struct foo
{
    int a;
};
	     ]]>
	   </programlisting>
	 </informalexample>

	 <para>
	   For structs EWG generates low-level and high-level wrappers.
	   The low level wrappers are purely procedural but still provide full access
	   to C structs. The high level wrappers use the low level wrappers to provide
	   object oriented access. Lets have a look at the generated low level wrapper for 
	   <literal>struct foo</literal> first:
	 </para>

	 <informalexample>
	   <programlisting>
	     <![CDATA[
class FOO_STRUCT_EXTERNAL

feature {NONE} -- Implementation

    sizeof_external: INTEGER

    get_a_external (item: POINTER): INTEGER

    set_a_external (a_item: POINTER; a_value: INTEGER)

end
	     ]]>
	   </programlisting>
	 </informalexample>

	 <para>
	   To use this wrapper directly (although this is not recommended)
	   inherit from <literal>FOO_STRUCT_EXTERNAL</literal>. 
	   To create or free a struct one can use the <literal>malloc</literal> and
	   <literal>free</literal> functions from the EWG runtime library. But to create (malloc) a struct
	   I need to know how big it is, well thats what <literal>FOO_STRUCT_EXTERNAL.sizeof_external</literal>
	   is for. The return value of <literal>malloc</literal> will be a POINTER. This is the reference to my
	   newly created struct. To set member <literal>a</literal> to <literal>3</literal> one can write
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
set_a_external (pointer, 3)
	     ]]>
	   </programlisting>
	 </informalexample>
	 <para>
	   To read member <literal>a</literal>, write
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
i := get_a_external (pointer)
	     ]]>
	   </programlisting>
	 </informalexample>
	 <para>
	   As you can see the first parameter here is always a
	   pointer to the struct. 
	 </para>

      </section>
      <section id="high_level_structs">
	 <title>High Level Struct Wrappers</title>
	 <para>
	   As hinted in the previous section, the low level wrappers are not meant to be used directly.
	   They give you a complete, but purely imperative API to deal with structs. The high level struct wrappers
	   on the other hand provide an object oriented way to handle structs. The idea is that every struct
	   you use from within Eiffel has a counterpart, the wrapper object. For every struct that EWG parses
	   it generates the corresponding wrapper class. Every struct wrapper class inherits from
	   <literal>EWG_STRUCT</literal> which is a deferred class with the following interface:
	 </para>


	 <informalexample>
	   <programlisting>
	     <![CDATA[
deferred class interface EWG_STRUCT

feature(s) from EWG_STRUCT  -- Access

    item: POINTER
        require
            exists: exists
        ensure
            item_not_default_pointer: Result /= default_pointer

    sizeof: INTEGER
            -- Size of the struct in bytes
	     -- This needs to be redefined by the
	     -- descendant.

    is_shared: BOOLEAN
            -- Is the contents of `item' referenced by other C or Eiffel code?
	     -- If `is_shared' is `True' then when the current object will be
	     -- collected by the garbage collector, the wrapped struct will
	     -- also be freed.
	     -- This is a good idea, only if you can be sure that when the
	     -- Eiffel object gets collected, the C side does not have a reference
	     -- to the wrapped struct anymore.
        require
	     exists: exists

    exists: BOOLEAN
            -- Does `item' point to a valid C struct ?

invariant

    managed_data_not_void: managed_data /= Void;

    managed_capacity_equals_sizeof: exists implies managed_data.capacity = sizeof;

end of deferred EWG_STRUCT
	     ]]>
	   </programlisting>
	 </informalexample>

	 <para>
	   As you can see the interface offers you direct access to the wrapped struct through the
	   <literal>item</literal> query. <literal>sizeof</literal> tells you how many bytes the
	   struct value occupies. With <literal>exits</literal> you can check if this wrapper is attached
	   to a valid (non <literal>NULL</literal>) struct value. The boolean query <literal>is_shared</literal>
	   tells you whether the memory occupied by the wrapped struct value will be freed when the wrapper
	   object gets collected or not. You decide whether a struct wrapper is shared or not by using a corresponding
	   creation routine (Obviously the ones with <literal>shared</literal> in its name create shared struct wrapper
	   and the ones with <literal>unshared</literal> create ones who are not) Every struct wrapper has
	   the same creation routines. You can see them in the interface of <literal>FOO_STRUCT</literal>, the
	   high level wrapper class for <literal>struct foo</literal>:
	 </para>

	 <informalexample>
	   <programlisting>
	     <![CDATA[
class interface FOO_STRUCT

creation

    make_new_unshared
            -- Create a new pointer wrapper to a new struct.
	     -- Allocates as much new memory as the struct needs.
	     -- 'unshared' means if the Current object
	     -- gets collected by the garbage collector,
	     -- the memory allocated for the struct will
	     -- be freed as well.
        ensure
            exists: exists;
	     is_not_shared: not is_shared

    make_new_shared
            -- Create a new pointer wrapper to a new struct.
	     -- Allocates as much new memory as the struct needs.
	     -- 'shared' means if the Current object
	     -- gets collected by the garbage collector,
	     -- the memory allocated for the struct will
	     -- not be freed as well.
        ensure
	     exists: exists;
	     is_shared: is_shared

    make_unshared (a_item: POINTER)
            -- Create a new pointer wrapper to a given struct.
	     -- 'unshared' means if the Current object
	     -- gets collected by the garbage collector,
	     -- the memory allocated for the struct will
	     -- be freed as well.
        require
	     a_item_not_default_pointer: a_item /= default_pointer
        ensure
	     exists: exists;
	     item_set: item = a_item;
	     is_not_shared: not is_shared

    make_shared (a_item: POINTER)
            -- Create a new pointer wrapper to a given struct.
	     -- 'shared' means if the Current object
	     -- gets collected by the garbage collector,
	     -- the memory allocated for the struct will
	     -- not be freed as well.
        require
	     a_item_not_default_pointer: a_item /= default_pointer
        ensure
	     exists: exists;
	     item_set: item = a_item;
	     is_shared: is_shared

feature(s) from FOO_STRUCT  -- Member Access

    a: INTEGER

    set_a (a_value: INTEGER)

invariant

    managed_data_not_void: managed_data /= Void;

    managed_capacity_equals_sizeof: exists implies managed_data.capacity = sizeof;

end of FOO_STRUCT
	     ]]>
	   </programlisting>
	 </informalexample>
	 
	 <para>
	   Every high level struct wrapper class offers four creation routines. Two to create shared wrapper object,
	   and two to create unshared unshared ones. Additionally you can create a wrapper that will attach to an
	   already existing C struct value, or you create a struct wrapper that automatically creates its own struct
	   value to wrap.
	   To create a struct wrapper that automatically creates a new struct value use a creation
	   routine with <literal>new</literal> in it's name. To create a struct wrapper that attaches to an existing
	   C struct value, use a creation routine that hasn't.
	 </para>
	 <para>
	   For every member in the C struct, the high level struct wrapper class offers a <literal>getter</literal>
	   and a <literal>setter</literal> (Actually some members only have a <literal>getter</literal>, such
	   as <literal>const</literal> members). The following code snippet demonstrates how to use the high level
	   struct wrapper class:
	 </para>

	 <informalexample>
	   <programlisting>
	     <![CDATA[
test_foo is
    local
        foo: FOO_STRUCT
    do
        create foo.make_new_unshared
	 foo.set_a (10)
	 print (foo.get_a.out)
    end
	     ]]>
	   </programlisting>
	 </informalexample>
      </section>
    </section>

    <section id="enums">
      <title>Enums</title>
      <para>
	 This section describes what code gets generated for a C enum declaration and how 
	 to use that code.
      </para>

      <para>
	 Let us look at the following enum declaration (taken from the <literal>simple-example</literal>)
      </para>
      <informalexample>
	 <programlisting>
	   <![CDATA[
typedef enum
{
    red,
    blue,
    green
} colors;
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 <literal>colors</literal> is an <literal>alias</literal> for an anonymous <literal>enum</literal>.
	 EWG generates an Eiffel wrapper class for it in the cluster
	 <literal>eiffel\external\enum</literal>:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
class interface COLORS_ENUM_EXTERNAL

feature(s) from COLORS_ENUM_EXTERNAL

    red: INTEGER

    blue: INTEGER

    green: INTEGER

end of COLORS_ENUM_EXTERNAL
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 The name of the class is <literal>COLORS_ENUM_EXTERNAL</literal>. 
	 Since Eiffel does not have the <literal>enum</literal> concept, enums are mapped as <literal>INTEGER</literal>
	 constants in Eiffel. Simply inherit from <literal>COLORS_ENUM_EXTERNAL</literal> wherever you want to use them.
      </para>

    </section>

    <section id="callbacks">
      <title>Callbacks</title>
      <para>
	 This section describes what code gets generated for C callbacks and how 
	 to use that code. Now first of all its not as trivial to define what a 
	 <literal>callback</literal> is. EWG defines callbacks as pointers to functions.
	 Wherever it sees a pointer to a function, it generates a callback wrapper.
	 Of course chances are some pointers to functions are not meant to be callbacks,
	 but in this case we can simply ignore the generated code.
      </para>
      
      <para>
	 It is important to understand that there is an inherent problem when wrapping callbacks in Eiffel.
	 For example the following callback:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
		     typedef void (*void_callback) (void);
	   ]]>
	 </programlisting>
      </informalexample>
      
      <para>
	 Does not convey any state when invoked (other than it has been invoked).
	 This is the reason for the following limitation: One can only register
	 one Eiffel callback receiver per callback type. If more receivers were allowed
	 how would one decide on the invocation of a callback which receiver is meant?
	 In practice this limitation is usually of no concern. Most C libraries have adopted
	 a pseudo OO technique of supplying a user definable parameter as the first parameter
	 on every callback. This parameter can be used to do further dispatching.
	 Have a look a the GTK or OpenGL examples to see how to do this.
      </para>
      
      <note><para>
	 A solution to overcome this limitation using dynamic function generation is being worked on.
      </para></note>

      <para>
	 Let us look at the following declarations (taken from the <literal>callback-example</literal>)
      </para>
      <informalexample>
	 <programlisting>
	   <![CDATA[
typedef void (*sample_callback_type) (void* pdata, int a_event_type);

// make `sample_callback_type' receive events.
void register_callback (sample_callback_type a_callback, void* pdata);

// make all registered callbacks receive an event
void trigger_event (int a_event_type);
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 <literal>sample_callback_type</literal> is the actual callback.
	 <literal>register_callback</literal> is used to register a given callback receiver, so that it gets called
	 whenever one calls <literal>trigger_event</literal>.
	 The two function declarations are wrapped as usual. For <literal>sample_callback_type</literal> EWG generates
	 two classes. Both are located in <literal>eiffel\abstraction\callback</literal>. Actually EWG generates lower level
	 classes two, even special C code, but these are omitted here. The two classes of interest are
	 <literal>SAMPLE_CALLBACK_TYPE_DISPATCHER</literal> and <literal>SAMPLE_CALLBACK_TYPE_CALLBACK</literal>.
	 The first one is the singleton that you have to create in order to establish the C-Eiffel bridge.
	 Use <literal>SAMPLE_CALLBACK_TYPE_DISPATCHER.c_dispatcher</literal> whenever you need to provide the C side
	 with a pointer to the callback receiver. The creation routine of <literal>SAMPLE_CALLBACK_TYPE_DISPATCHER</literal>
	 expects an object of type <literal>SAMPLE_CALLBACK_TYPE_CALLBACK</literal>. Create your own callback receiver class
	 let it inherit from <literal>SAMPLE_CALLBACK_TYPE_DISPATCHER</literal> and use an object of your new class for the
	 creation routine argument. Here are the interfaces of the generated classes:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
class interface SAMPLE_CALLBACK_TYPE_DISPATCHER

create

    make (a_callback: SAMPLE_CALLBACK_TYPE_CALLBACK)
        require
	     a_callback_not_void: a_callback /= Void

feature(s) from SAMPLE_CALLBACK_TYPE_DISPATCHER

    callback: SAMPLE_CALLBACK_TYPE_CALLBACK

    c_dispatcher: POINTER

invariant

    callback_not_void: callback /= Void;

end of SAMPLE_CALLBACK_TYPE_DISPATCHER
	   ]]>
	 </programlisting>
      </informalexample>

      <informalexample>
	 <programlisting>
	   <![CDATA[
deferred class interface SAMPLE_CALLBACK_TYPE_CALLBACK

feature(s) {SAMPLE_CALLBACK_TYPE_DISPATCHER} from SAMPLE_CALLBACK_TYPE_CALLBACK

    on_callback (a_pdata: POINTER; a_a_event_type: INTEGER)

end of deferred SAMPLE_CALLBACK_TYPE_CALLBACK
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 Assuming that you have created a class <literal>MY_CALLBACK_RECEIVER</literal> which inherits
	 from <literal>SAMPLE_CALLBACK_TYPE_CALLBACK</literal>, the following code demonstrates the
	 use of callbacks
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
feature

    make is
        do
             -- Establish the C<->Eiffel bridge.
	      -- From now on, whenever `trigger_event_external' gets called
	      -- `MY_CALLBACK_RECEIVER.on_callback' gets called too.
	      register_callback_external (dispatcher.c_dispatcher)
        end

    dispatcher: SAMPLE_CALLBACK_TYPE_DISPATCHER is
        local
	     my_callback_receiver: MY_CALLBACK_RECEIVER
        once
	     create my_callback_receiver.make
	     create Result.make (my_callback_receiver)
        end

    trigger is
        do
	     trigger_event_external
	     -- `MY_CALLBACK_RECEIVER.on_callback' has now been called
        end
	   ]]>
	 </programlisting>
      </informalexample>

    </section>

  </section>


  <section id="the_build_process">
    <title>The Build Process</title>

    <para>
      Although EWG can be used without the <emphasis>GOBO</emphasis> tools <emphasis>geant</emphasis> and
      <emphasis>gexace</emphasis> it is highly recommended to use them. EWG comes with reusable 
      <emphasis>geant</emphasis>-scripts that help you create a cross-eiffel-compiler, cross-c-compiler and
      cross-platform automated build process.
    </para>

    <para>
      A good way to get started with the build process is to go to the <emphasis>simple</emphasis> or
      <emphasis>callback</emphasis> example and run geant with the <literal>--verbose</literal> option.
    </para>
    <para>
      TODO: Documentation for build process
    </para>

  </section>

  <section id="the_runtime_library">
    <title>The Runtime Library</title>


    <para>
      EWG comes with a set of classes that help you deal with external C code in a generic and portable way. 
      You can find those classes in the directory <literal>${EWG}/library/runtime</literal>.
      If you want to distribute a wrapper generated by EWG, you don't need to provide the full EWG package
      alongside. The runtime library and the <literal>${EWG}/misc</literal> directory are sufficient.
    </para>

    <para>
      This cluster provides a generic way to deal with:
    </para>
    
    <itemizedlist>
      <listitem><para>C zero terminated strings</para></listitem>      
      <listitem><para>Arrays</para></listitem>      
      <listitem><para>Pointers</para></listitem>      
    </itemizedlist>
    
    <section id="pointers">
      <title>Pointers</title>
      <para>
	 EWG provides a class called
	 <literal>EWG_MANAGED_POINTER</literal> (it is very similar
	 and actually inspired by ISEs
	 <literal>MANAGED_POINTER</literal> class). This class
	 encapsulates C memory areas on a higher level than the
	 kernel class <literal>POINTER</literal>. TODO: continue
      </para>
    </section>

    
    <section id="wrapper_objects">
      <title>Wrapper Objects</title>

      <para>
	 It is important to know that instances of C structs, unions
	 or really any C memory area are by default not first class
	 Eiffel objects. Instead EWG creates classes who's instances
	 can serve as companion objects. For example let's look at
	 the following struct:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
struct person
{
    char* first_name;
    char* last_name;
    char* phone_number;
};
	   ]]>
	 </programlisting>
      </informalexample>

      <para>
	 For this struct EWG will create a class
	 <literal>EWG_PERSON_STRUCT_EXTERNAL</literal>, which
	 provides low level and non-object-oriented access to the
	 struct. EWG will also create a class called
	 <literal>EWG_PERSON_STRUCT</literal> which uses the former
	 class to provide the companion objects. In the next figure
	 you can see how the relate.
      </para>

      <para>
	 <mediaobjectco>
	   <imageobjectco>
	     <imageobject>
		<imagedata align="center" fileref="image/struct_wrapper.png"></imagedata>
	     </imageobject>
	   </imageobjectco>
	 </mediaobjectco>
      </para>

      <para>
	 The Eiffel wrapper object really only stores a reference
	 (<literal>item</literal>) to the C struct instance. When you
	 invoke <literal>person.first_name</literal>, where
	 <literal>person</literal> is of type
	 <literal>PERSON_STRUCT</literal> then the actual data will
	 be retrieved from the C struct instance being referenced via
	 <literal>item</literal>.
      </para>

    </section>


    <section id="wrapper_modes">
      <title>Wrapper Modes</title>
      <para>
	 Wrappers based on pointers (EWG_MANAGED_POINTER, EWG_STRUCT
	 and EWG_UNION) can be created to be
	 <literal>shared</literal> or <literal>unshared</literal>,
	 <literal>new</literal> or <literal>existing</literal> via
	 one of the following creation procedures:
	 
	 <itemizedlist>
	   <listitem><para>make_shared </para></listitem>
	   <listitem><para>make_unshared </para></listitem>
	   <listitem><para>make_new_shared </para></listitem>
	   <listitem><para>make_new_unshared </para></listitem>
	 </itemizedlist>

	 Note that there are two orthogonal concepts used here (see
	 next figure).

      </para>

      <para>
	 <mediaobjectco>
	   <imageobjectco>
	     <imageobject>
		<imagedata align="center" fileref="image/wrapper_creation_matrix.png"></imagedata>
	     </imageobject>
	   </imageobjectco>
	 </mediaobjectco>
      </para>

      <section id="shared_vs_unshared">
	 <title>Shared vs. Unshared</title>


	 <itemizedlist>
	   <listitem><para>When <emphasis>shared</emphasis> wrapper objects will be collected, their corresponding C memory will not be freed.</para></listitem>
	   <listitem><para>When <emphasis>unshared</emphasis> wrapper objects will be collected, they will also free their corresponding C memory</para></listitem>
	 </itemizedlist>
      </section>

      <section id="new_vs_existing">
	 <title>New vs. Existing</title>
	 <itemizedlist>
	   <listitem><para> When creating a wrapper object with a
	   creation procedure which contains <literal>new</literal>,
	   then the wrapper object will itself allocate memory for
	   the value to wrap. Use such creation procedures to create
	   wrapper objects and the wrapped object yourself at the
	   same time. </para></listitem>

	   <listitem><para> When creating a wrapper object with a
	   creation procedure which does not contain
	   <literal>new</literal>, then it will take one parameter
	   <literal>a_item: POINTER</literal>. Use such creation
	   procedures to create wrapper objects for C values which
	   already exist. Pass a pointer to the C value to wrap as
	   <literal>a_item</literal>.</para></listitem>

	 </itemizedlist>
      </section>

    </section>

    <para>
      TODO: Further documentation for runtime library
    </para>


  </section>

  <section id="the_config_file">
    <title>The Configuration File</title>

    <para>
      To customize the way EWG generates wrappers, you can provide a configuration file. This file usually named
      <filename>config.ewg</filename> is written in XML. This section will describe it's structure.
    </para>

    <note><para>
      Configuration support is quite new many very interesting things have
      not yet been implemented.  Basically all you can do so far is control
      what from a header should be wrapped and what not.
    </para></note>
    
    <para>
      Here is a simple example of how a config file can look like:
    </para>

    <informalexample>
      <programlisting>
	 <![CDATA[
<?xml version="1.0"?>
<ewg_config name="my_example">

<rule_list>
   <!-- This rule matches all C constructs who are named "foo". -->
   <!-- Matching constructs will be wrapped using EWGs defaults -->

<rule>
  <match>
     <identifier name="foo"/>
  </match>
  <wrapper type="default">
  </wrapper>
</rule>

  <!-- This rule matches all C constructs.         -->
  <!-- Matching constructs will be ignored.        -->
  <!-- Thus no wrapper will be generated for them  -->

<rule>
  <match>
  </match>
  <wrapper type="none">
  </wrapper>
</rule>

</rule_list>

</ewg_config>
	 ]]>
      </programlisting>
    </informalexample>

    <para>
      The concept used is very similar to the concept used in XSLT.
      You have a ordered list of rules. For every parsed C construct
      EWG will go through the list of rules and use the first rule
      that matches on the construct. If no rule matches the
      construct will be ignored.
    </para>

    <para>
      Each rule consists of two parts:
    </para>


    <variablelist>
      <varlistentry><term><literal>match</literal></term>
      <listitem>
	 <para>
	   Describing what C constructs shall be matched by this rule.
	 </para>
      </listitem>
      </varlistentry>
      <varlistentry><term><literal>wrapper</literal></term>
      <listitem>
	 <para>
	   Describing how the matched construct should be wrapped.
	   Right now all you can specify is the wrapper type that
	   should be used, using the <literal>type</literal>
	   attribute. You can choose between the
	   <literal>default</literal> wrapper, which will wrap the
	   construct using EWG defaults, or the
	   <literal>none</literal> wrapper, which will generate no
	   wrapper for the matched construct.
	 </para>
      </listitem>
      </varlistentry>
    </variablelist>

    <para>
      If the <literal>match</literal> element is empty, all
      constructs match, but you can use sub-elements to constrain
      what constructs should match:
    </para>

    <variablelist>
      <varlistentry><term><literal>header</literal></term>
      <listitem>
	 <para>
	   What header does the construct come from. Note that you
	   have to specify the exact header the construct comes
	   from. A header that only includes another header that
	   contains a construct, will not match. Here is an example
	   of how to use this element:
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
<?xml version="1.0"?>
<match>
   <header name=".*foo.h"/>
</match>
	     ]]>
	   </programlisting>
	 </informalexample>
	 <para>
	   Note that the value of <literal>name</literal> can be a
	   regular expression. In the above example any header that
	   ends with <literal>foo.h</literal> will match.
	 </para>
      </listitem>
      </varlistentry>
      <varlistentry><term><literal>identifier</literal></term>
      <listitem>
	 <para>
	   Constrains the name of elements. Here is an example:
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
<?xml version="1.0"?>
<match>
    <identifier name="foo"/>
</match>
	     ]]>
	   </programlisting>
	 </informalexample>
	 <para>
	   Note that the value of <literal>name</literal> can be a
	   regular expression.
	 </para>
      </listitem>
      </varlistentry>
      <varlistentry><term><literal>type</literal></term>
      <listitem>
	 <para>
	   Constrains the construct type. Here is an example:
	 </para>
	 <informalexample>
	   <programlisting>
	     <![CDATA[
<?xml version="1.0"?>
<match>
    <type name="function"/>
</match>
	     ]]>
	   </programlisting>
	 </informalexample>
	 <para>
	   Possible values for <literal>name</literal> are
	   
	   <itemizedlist>
	     <listitem><para><literal>any</literal></para></listitem>
	     <listitem><para><literal>none</literal></para></listitem>
	     <listitem><para><literal>struct</literal></para></listitem>
	     <listitem><para><literal>union</literal></para></listitem>
	     <listitem><para><literal>enum</literal></para></listitem>
	     <listitem><para><literal>function</literal></para></listitem>
	     <listitem><para><literal>callback</literal></para></listitem>
	   </itemizedlist>
	 </para>
      </listitem>
      </varlistentry>
    </variablelist>

    <para>
      You can choose more than one constraint per <literal>match</literal> clause.
      In which case you constrain the match clause to all individual constraints.
    </para>
    <!-- TODO: document construct type dependend wrapper-clause elements ('class_name') -->

    <section id="dependent_types">
      <title>Dependent Types</title>
      <para>
	 If you choose to include a type who depends on a type which
	 you choose to exclude, the dependent type will also be
	 included. Confused? Let's say you have:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
struct foo
{
    int i;
};
struct bar
{
    struct foo* pfoo;
};
	   ]]>
	 </programlisting>
      </informalexample>
      <para>
	 And you specify the following config file:
      </para>

      <informalexample>
	 <programlisting>
	   <![CDATA[
		     <?xml version="1.0"?>
		     <ewg_config>

<rule_list>
<rule>
<match>
<identifier name="bar"/>
</match>
<wrapper type="default">
</wrapper>
</rule>

<rule>
<match>
</match>
<wrapper type="none">
</wrapper>
</rule>
</rule_list>

</ewg_config>
	   ]]>
	 </programlisting>
      </informalexample>
      <para>
	 That would mean, <literal>struct bar</literal> will be
	 wrapped and <literal>struct foo</literal> will not be
	 wrapped. Now, because <literal>struct bar</literal> depends
	 on <literal>struct foo</literal>, <literal>struct
	 bar</literal> will be wrapped after all.
      </para>

    </section>
    
    <note><para>
      In the if you use <literal>ewg_library.eant</literal> based
      <literal>geant</literal> files, you can control whether
      <literal>ewg</literal> uses a config file via the
      <literal>ewg.use_config_file</literal> variable. Have a look
      at the GTK, SDL, OpenGL or BerkeleyDB examples to see how it
      is done. If you set this variable, the config file is expected
      to be named <literal>config.ewg</literal>.
    </para></note>

  </section>

</chapter>

